# Spring boot

- 简化Spring应用开发的一个框架； 
- 整个Spring技术栈的一个大整合； 
- J2EE开发的一站式解决方案； 

```java
@SpringBootApplication
public class StudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(StudyApplication.class, args);
    }
}
```

## 基础

### 自动配置原理

```java
@SpringBootApplication //标注主配置类
-@SpringBootConfiguration//封装了@Configuration，配置类并注入容器
--@Configuration
-@EnableAutoConfiguration//开启自动配置功能
--@AutoConfigurationPackage//扫描主配置类包及子包下的类
---@Import(AutoConfigurationPackages.Registrar.class)
--@Import(AutoConfigurationImportSelector.class)//导入自动配置选择器，扫描所有jar包下 `META-INF` 目录下的 `spring.factories` 文件
-@ComponentScan(excludeFilters =...)//扫描时排除策略
```

#### 概述

自动配置需要解三个问题：

- 满足什么样的**条件**？
- 创建**哪些** `Bean`？
- 创建的`Bean`的**属性**？

在我们引入 `spring-boot-starter-web` 依赖，会创建一个 8080 端口的内嵌 `Tomcat`，同时可以在 `application.yaml` 配置文件中通过 `server.port` 配置项自定义端口。那么这三个问题的答案如下：

- 满足什么样的**条件**：引入了 `spring-boot-starter-web` 依赖。
- 创建**哪些** Bean：内嵌的 Tomcat Bean。
- 创建的 Bean 的**属性**：在`application.yaml` 配置文件配置，具体配置项可看`ServerProperties`类。

```java
@Configuration // <1.1> 声明这是一个 Spring 配置类
@ConditionalOnWebApplication // <2.1>
@EnableConfigurationProperties(ServerProperties.class) // <3.1>
public class  EmbeddedWebServerFactoryCustomizerAutoConfiguration {

	@Configuration // <1.2>
	@ConditionalOnClass({ Tomcat.class, UpgradeProtocol.class })
	public static class TomcatWebServerFactoryCustomizerConfiguration {
		@Bean //声明该方法创建一个 Spring Bean
		public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(
				Environment environment, ServerProperties serverProperties) {
			// <3.2>
			return new TomcatWebServerFactoryCustomizer(environment, serverProperties);
		}
	}
	......
}

```

通过 `@Configuration` 注解的配置类`XXXXAutoConfiguration`，可以解决“创建哪些 Bean”的问题。

> Spring Boot 的`spring-boot-autoconfigure`项目，提供了大量框架的自动配置类。

通过`@Configuration`条件注解，可以解决“满足什么样的条件”的问题。

> Spring Boot 的 `condition`包下，提供了大量的条件注解。

通过`@EnableConfigurationProperties`注解，让 `XXXXProperties` 配置属性类生效（注入容器），可以解决“创建的 Bean 的属性”的问题。

```java
@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)
public class ServerProperties
		implements EmbeddedServletContainerCustomizer, EnvironmentAware, Ordered {
	private Integer port;
	private String contextPath;
	// ... 省略其它属性
}
```

> 通过 `@ConfigurationProperties` 注解，声明将 `xxxx` 前缀的配置项，设置到 `XXXXProperties `配置属性类中。

#### 自动配置类

在 Spring Boot 的`spring-boot-autoconfigure`项目，提供了大量框架的自动配置。

![企业微信截图_15894256072537](images/企业微信截图_15894256072537.png)

在我们通过 `SpringApplication#run()`方法，启动 Spring Boot 应用的时候，有个非常重要的组件`SpringFactoriesLoader` 类，会读取每个jar包 `META-INF` 目录下的 `spring.factories` 文件，获得**每个框架定义的需要自动配置的配置类**。

![企业微信截图_1589425806701](images/企业微信截图_1589425806701.png)

如此，原先 `@Configuration` 注解的配置类，就**升级**成类自动配置类。这样，Spring Boot 在获取到需要自动配置的配置类后，就可以自动创建相应的 Bean，完成自动配置的功能。

#### 条件注解

条件注解并非 Spring Boot 独有，而是在 Spring3.1 版本时，为了满足不同环境注册不同的 `Bean `，引入了`@Profile`注解。

```java
@Configuration
public class DataSourceConfiguration {
    @Bean
    @Profile("DEV")//在测试环境下，我们注册单机 MySQL 的 DataSource Bean。
    public DataSource devDataSource() {
        // ... 单机 MySQL
    }
    
    @Bean
    @Profile("PROD")//在生产环境下，我们注册集群 MySQL 的 DataSource Bean。
    public DataSource prodDataSource() {
        // ... 集群 MySQL
    }
}
```

在 Spring4 版本时，提供了 `@Conditional`注解，用于声明在配置类或者创建  `Bean ` 的方法上，表示需要满足指定条件才能生效。

```java
@Configuration
public class TestConfiguration {
    @Bean
    @Conditional(XXXCondition.class)//XXXCondition 需要我们自己实现 Condition 接口，提供具体的条件实现。
    public Object xxxObject() {
        return new Object();
    }
}
```

Spring Boot 进一步增强，提供了常用的条件注解：

- `@ConditionalOnBean`：当容器里有指定 Bean 的条件下
- `@ConditionalOnMissingBean`：当容器里没有指定 Bean 的情况下
- `@ConditionalOnSingleCandidate`：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean
- `@ConditionalOnClass`：当类路径下有指定类的条件下
- `@ConditionalOnMissingClass`：当类路径下没有指定类的条件下
- `@ConditionalOnProperty`：指定的属性是否有指定的值
- `@ConditionalOnResource`：类路径是否有指定的值
- `@ConditionalOnExpression`：基于 SpEL 表达式作为判断条件
- `@ConditionalOnJava`：基于 Java 版本作为判断条件
- `@ConditionalOnJndi`：在 JNDI 存在的条件下差在指定的位置
- `@ConditionalOnNotWebApplication`：当前项目不是 Web 项目的条件下
- `@ConditionalOnWebApplication`：当前项目是 Web项 目的条件下

#### 配置属性

Spring Boot 约定读取 `application.yaml`、`application.properties` 等配置文件，从而实现创建 Bean 的自定义属性配置，甚至可以搭配 `@ConditionalOnProperty` 注解来取消 Bean 的创建。

#### 内置starter

我们在使用 Spring Boot 时，并不会直接引入 [`spring-boot-autoconfigure`](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-autoconfigure) 依赖，而是使用 Spring Boot 内置提供的 Starter 依赖。例如说，我们想要使用 SpringMVC 时，引入的是 [`spring-boot-starter-web`](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web) 依赖。

因为 Spring Boot 提供的自动配置类，基本都有 `@ConditionalOnClass` 条件注解，判断我们项目中存在指定的类，才会创建对应的 Bean。而拥有指定类的前提，一般是需要我们引入对应框架的依赖。

因此，在我们引入 `spring-boot-starter-web` 依赖时，它会帮我们自动引入相关依赖，从而保证自动配置类能够生效，创建对应的 Bean

Spring Boot 内置了非常多的 Starter，方便我们引入不同框架，并实现自动配置。

#### 自定义starter

在一些场景下，我们需要自己实现自定义 Starter 来达到自动配置的目的。例如说：

- 三方框架并没有提供 Starter，比如说 [Swagger](https://github.com/swagger-api)、[XXL-JOB](https://github.com/xuxueli/xxl-job) 等。
- Spring Boot 内置的 Starter 无法满足自己的需求，比如说 [`spring-boot-starter-jdbc`](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc) 不提供多数据源的配置。
- 随着项目越来越大，想要提供适合自己团队的 Starter 来方便配置项目，比如说永辉彩食鲜 [csx-bsf-all](https://gitee.com/yhcsx/csx-bsf-all) 项目。

| 场景                         | 命名规则                            | 示例                                       |
| -------------------------- | ------------------------------- | ---------------------------------------- |
| **Spring Boot 内置** Starter | `spring-boot-starter-{框架}`      | `spring-boot-starter-web`                |
| 框架 **自定义** Starter         | `{框架}-spring-boot-starter`      | [`mybatis-spring-boot-starter`](https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter) |
| 公司 **自定义** Starter         | `{公司}-spring-boot-starter-{框架}` |                                          |

重点是：

- 创建`XXXXAutoConfiguration`配置类；
- 创建`XXXXProperties`属性 包装类，并通过`@ConfigurationProperties(prefix = "xxxx")`映射配置文件；
- 在 `resources` 目录下创建，创建 `META-INF` 目录，然后在该目录下创建 [`spring.factories`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-47/yunai-server-spring-boot-starter/src/main/resources/META-INF/spring.factories) 文件，添加自动化配置类为 `XXXXAutoConfiguration`；

## 开发工具

### lombok

[Lombok](https://github.com/rzwitserloot/lombok) 是一个 Java 工具，通过使用其定义的注解，自动生成常见的冗余代码，提升开发效率。

Lombok 的注解非常多，我们逐个来看看。

- @Getter 注解，添加在类或属性上，生成对应的 get 方法。
- @Setter 注解，添加在类或属性上，生成对应的 set 方法。
- @ToString 注解，添加在类上，生成 toString 方法。
- @EqualsAndHashCode 注解，添加在类上，生成 equals 和 hashCode 方法。
- @AllArgsConstructor、@RequiredArgsConstructor、@NoArgsConstructor 注解，添加在类上，为类自动生成对应参数的构造方法。
- @Data 注解，添加在类上，是 5 个 Lombok 注解的组合。
- @CommonsLog、@Flogger、@Log、@JBossLog、@Log4j、@Log4j2、@Slf4j、@Slf4jX 注解，添加在类上，自动为类添加对应的日志支持。
- @Builder 注解，添加在类上，给该类加个构造者模式 Builder 内部类。
- @Synchronized 注解，添加在方法上，添加同步锁。
- @SneakyThrows 注解，添加在方法上，给该方法添加 try catch 代码块。
- @NonNull 注解，添加在方法参数、类属性上，用于自动生成 null 参数检查。若确实是 null 时，抛出 NullPointerException 异常。

常用@Data、@Slf4j、@Builder、@SneakyThrows、@NonNull。

```java
//源码
@SneakyThrows
public static void tryCatch(@NonNull String name, @NonNull String age{}

//编译后
public static void tryCatch(@NonNull String name, @NonNull String age) {
    try {
        if (name == null) {
            throw new NullPointerException("name is marked non-null but is null");
        } else if (age == null) {
            throw new NullPointerException("age is marked non-null but is null");
        }
    } catch (Throwable var3) {
        throw var3;
    }
}、
```

### MapStruct 

`MapSturct` 是一个生成类型安全， 高性能且无依赖的 JavaBean 映射代码的注解处理器。

```java
@Mapper
public interface TargetMapper {
    TargetMapper INSTANCE = Mappers.getMapper(TargetMapper.class);
    @Mappings(value={
	@Mapping(target="abc", source="cba"),
	@Mapping(target="acc", source="cca", qualifiedByName="mapMethodName2"), //定义转换的方法
	@Mapping(target="aaa",  constant="123")  //定义常量	})
    Target source2target(Source source);
}
```

概述：

- 支持maven/gradle/ant工具所构建的项目；
- 在某些情况下，可能需要手动实现从一种类型到另一种类型的特定映射，而MapStruct无法生成这种映射，你可以向映射器中**添加自定义方法**；
- 可以用**多个源对象的数据映射到一个对象**上，也就是说可以同时把A和B的数据复制到C对象中；
- 可以通过引用更新目标对象，默认在复制时会生成新的对象并返回，但有时候可能不需要生成新的对象，只希望它在既有对象上进行复制；
- Bean的字段如果没有提供getter/setter方法也可以进行复制，它会通过实例直接访问属性来达到目的；
- 如果Bean提供了自己的工厂，即通过Builder构造自己，也可以被识别到；
- 获取映射器之后客户端才能调用，获取的方式支持Mappers工厂、CDI依赖注入和Spring依赖注入；
- **类型隐式转换**；
- **嵌套对象自动映射**；
- 在当前映射器中可以调用其他映射器，可以是自定义映射器；
- **集合映射**；
- 流映射；
- 枚举类映射；
- **映射字段控制**：常量，默认值，忽略字段，NULL值检查和处理策略，异常处理；
- 映射配置共享、继承和反向映射；
- 装饰器映射，也就是在映射前后做一些自定义操作；
- 提供SPI接口，可以修改框架的部分实现；

### fastJson

需要写一个配置类WebConfig实现WebMvcConfigurer接口，然后重写configureMessageConverters方法。

```java
@Configuration
public class CustomWebConfig implements WebMvcConfigurer {
    /**
     * description: 添加JSON消息转换器
     * (1)源码分析可知，返回json的过程为：Controller调用结束后返回一个数据对象，for循环遍历conventers，
     * 找到支持application/json的HttpMessageConverter，然后将返回的数据序列化成json。
     * (2)由于是list结构，我们添加的fastjson在最后。因此必须要将jackson的转换器删除，
     * 不然会先匹配上jackson，导致没使用fastjson。
     * version: 1.0
     * date: 2020/5/15 16:40
     * author: 古陵逝烟
     *
     * @param converters 转换器列表
     * @return void
     **/
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        for (int i = converters.size() - 1; i >= 0; i--) {
            if (converters.get(i) instanceof MappingJackson2HttpMessageConverter) {
                converters.remove(i);
            }
        }
        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
        //自定义fastjson配置
        FastJsonConfig config = new FastJsonConfig();
        config.setSerializerFeatures(
                SerializerFeature.WriteMapNullValue,        // 是否输出值为null的字段,默认为false,我们将它打开
                SerializerFeature.WriteNullListAsEmpty,     // 将Collection类型字段的字段空值输出为[]
                SerializerFeature.WriteNullStringAsEmpty,   // 将字符串类型字段的空值输出为空字符串
                SerializerFeature.WriteNullNumberAsZero,    // 将数值类型字段的空值输出为0
                SerializerFeature.WriteDateUseDateFormat,
                SerializerFeature.DisableCircularReferenceDetect    // 禁用循环引用
        );
        fastJsonHttpMessageConverter.setFastJsonConfig(config);
        // 添加支持的MediaTypes;不添加时默认为*/*,也就是默认支持全部
        // 但是MappingJackson2HttpMessageConverter里面支持的MediaTypes为application/json
        // 参考它的做法, fastjson也只添加application/json的MediaType
        List<MediaType> fastMediaTypes = new ArrayList<>();
        fastMediaTypes.add(MediaType.APPLICATION_JSON);
        fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes);
        converters.add(fastJsonHttpMessageConverter);
    }
}
```

## web开发

### spring MVC

`spring-boot-starter-web`实现 SpringMVC 的自动化配置

#### 注解

- `@Controller`
- `@RestController` 是 `@Controller` 和 `@ResponseBody` 的组合注解。
- `@RequestMapping`
- `@GetMapping`
- `@PostMapping`
- `@PutMapping`
- `@RequestParam` 
- `@PathVariable` 

#### 全局统一返回

一般来说，统一的全局返回信息如下：

- 成功时，返回**成功的状态码** + **数据**。
- 失败时，返回**失败的状态码** + **错误提示**。

在全局统一返回里，我们至少需要定义三个字段：

- `code`：状态码。无论是否成功，必须返回。

> 成功时，状态码为 0 。
>
> 失败时，对应业务的错误码。

- `data`：数据。成功时，返回该字段。
- `message`：错误提示。失败时，返回该字段。

在 `Spring MVC `中，可以使用通过实现 `ResponseBodyAdvice `接口，并添加 `@ControllerAdvice`接口，拦截 `Controller `的返回结果。

```java
//只拦截 Controller 所在包，避免其它类似 swagger 提供的 API 被切面拦截
@ControllerAdvice(basePackages = "com.study.dxbm.controller")
public class GlobalResponseBodyHandler implements ResponseBodyAdvice {
    @Override
    public boolean supports(MethodParameter methodParameter, Class aClass) {
        return true;//true表示拦截 Controller 所有 API 接口的返回结果。
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter methodParameter, MediaType mediaType, Class aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {
        // 如果已经是 CommonResult 类型，则直接返回
        if (body instanceof CommonResult) {
            return body;
        }
       //若controller返回的是String，则这里需要单独处理，否则会报错
        if(body instanceof String){
            return JSON.toJSONString(CommonResult.success(body));
        }
        // 如果不是，则包装成 CommonResult 类型
        return CommonResult.success(body);
    }
}
```

在项目中，我们可能会引入 `Swagger `等库，也使用 Controller 提供 API 接口，那么我们显然不应该让 `GlobalResponseBodyHandler `去拦截这些接口，**毕竟它们并不需要我们去替它们做全局统一的返回**。

API 接口既然返回结果被拦截到，**约定**就是成功返回，所以使用 `CommonResult#success` 方法，进行包装成**成功**的 `CommonResult `返回。那么，如果我们希望 API 接口是**失败**的返回呢？我们**约定**在 Controller 抛出异常。

`ResponseBodyAdvice `用于对响应内容 Response Body 进行切面拦截。而相对的，Spring MVC 也提供了 `RequestBodyAdvice `，用于对请求内容 Request Body 进行切面拦截。

#### 全局异常处理

> 创建 ServiceExceptionEnum 枚举类，枚举项目中的错误码；
>
> 创建 ServiceException 异常类，继承 RuntimeException 异常类，用于定义业务异常；
>
> 创建 GlobalExceptionHandler 类，全局统一返回的处理器；

```java
@ControllerAdvice(basePackages = "com.study.dxbm.controller")//拦截哪些类里方法抛出的异常
@Slf4j
public class GlobalExceptionHandler {
    /**
     * 处理 ServiceException 异常
     */
    @ResponseBody
    @ExceptionHandler(value = ServiceException.class)//拦截什么异常
    public CommonResult serviceExceptionHandler(HttpServletRequest req, ServiceException ex) {
        log.debug("[serviceExceptionHandler]", ex);
        // 包装 CommonResult 结果
        return CommonResult.error(ex.getCode(), ex.getMessage());
    }

    /**
     * 处理 MissingServletRequestParameterException 异常，如SpringMVC 参数不正确
     */
    @ResponseBody
    @ExceptionHandler(value = MissingServletRequestParameterException.class)
    public CommonResult missingServletRequestParameterExceptionHandler(HttpServletRequest req, MissingServletRequestParameterException ex) {
        log.debug("[missingServletRequestParameterExceptionHandler]", ex);
        // 包装 CommonResult 结果
        return CommonResult.error(ServiceExceptionEnum.MISSING_REQUEST_PARAM_ERROR.getCode(),
                ServiceExceptionEnum.MISSING_REQUEST_PARAM_ERROR.getMessage());
    }

    /**
     * 处理其它 Exception 异常
     */
    @ResponseBody
    @ExceptionHandler(value = Exception.class)
    public CommonResult exceptionHandler(HttpServletRequest req, Exception e) {
        // 记录异常日志
        log.error("[exceptionHandler]", e);
        // 返回 ERROR CommonResult
        return CommonResult.error(ServiceExceptionEnum.SYS_ERROR.getCode(),
                ServiceExceptionEnum.SYS_ERROR.getMessage());
    }
}
```



在类上，添加 `@ControllerAdvice` 注解。这一点，和 GlobalResponseBodyHandler 是一样的。但不会实现 ResponseBodyAdvice 接口，因为咱不需要拦截接口返回结果，进行修改。

在 `#exceptionHandler(...)` 方法中，我们还多使用 `logger` 打印了错误日志，方便我们接入 ELK 等日志服务，发起告警，通知我们去排查解决。

通过添加 @ExceptionHandler 注解，定义每个方法对应处理的异常。并且，也添加了 `@ResponseBody` 注解，标记直接使用返回结果作为 API 的响应。

#### HandlerInterceptor

在使用 SpringMVC 的时候，我们可以使用 HandlerInterceptor，拦截 SpringMVC 处理请求的过程，自定义前置和处理的逻辑。例如说：

- 日志拦截器，记录请求与响应。这样，我们可以知道每一次请求的参数，响应的结果，执行的时长等等信息。
- 认证拦截器，我们可以解析前端传入的用户标识，例如说 `access_token` 访问令牌，获得当前用户的信息，记录到 ThreadLocal 中。这样，后续的逻辑，只需要通过 ThreadLocal 就可以获取到用户信息。
- 授权拦截器，我们可以通过每个 API 接口需要的授权信息，进行判断，当前请求是否允许访问。例如说，用户是否登陆，是否有该 API 操作的权限等等。
- 限流拦截器，我们可以通过每个 API 接口的限流配置，进行判断，当前请求是否超过允许的请求频率，避免恶意的请求，打爆整个系统。

HandlerInterceptor 接口，定义了三个拦截点。代码如下：

```java
// HandlerInterceptor.java
public interface HandlerInterceptor {

	default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)throws Exception {
		return true;
	}

	default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			@Nullable ModelAndView modelAndView) throws Exception {
	}

	default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable Exception ex) throws Exception {
	}
}

```

> `#preHandle(...)` 方法，实现 `handler` 的**前**置处理逻辑。当返回 `true` 时，**继续**后续 `handler` 的执行；当返回 `false` 时，**不进行**后续 `handler` 的执行。
>
> `#postHandle(...)` 方法，实现 `handler` 的**后**置处理逻辑。
>
> `#afterCompletion(...)` 方法，整个 `handler` 执行完成，并且拦截器**链**都执行完前置和后置的拦截逻辑，实现**请求完成后**的处理逻辑。**注意**，只有 `#preHandle(...)` 方法返回 `true` 的 HandlerInterceptor 拦截器，才能执行 `#afterCompletion(...)` 方法，因为这样HandlerInterceptor **执行完成**才有效。

多个 HandlerInterceptor 们，可以组成一个 Chain **拦截器链**。那么，整个执行的过程，就变成：

> 首先，按照 HandlerInterceptor 链的**正序**，执行 `#preHandle(...)` 方法。
>
> 然后，执行 `handler` 的逻辑处理。
>
> 之后，按照 HandlerInterceptor 链的**倒序**，执行 `#postHandle(...)` 方法。
>
> 最后，按照 HandlerInterceptor 链的**倒序**，执行 `#afterCompletion(...)` 方法。

```java
//自定义拦截器，实现HandlerInterceptor接口
public class FirstInterceptor implements HandlerInterceptor {
	private Logger logger = LoggerFactory.getLogger(getClass());
	
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
    			Object handler) {
        logger.info("[preHandle][handler({})]", handler);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, 				ModelAndView modelAndView) throws Exception {
        logger.info("[postHandle][handler({})]", handler);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object 							handler, Exception ex) throws Exception {
        logger.info("[afterCompletion][handler({})]", handler, ex);
    }

}

//配置类，添加自定义的拦截器，实现WebMvcConfigurer接口
@Configuration
public class SpringMVCConfiguration implements WebMvcConfigurer {

    @Bean
    public FirstInterceptor firstInterceptor() {
        return new FirstInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 添加到拦截器注册表
        registry.addInterceptor(this.firstInterceptor()).addPathPatterns("/**");
    }
}
```

#### Servlet、Filter、Listene

我们有**两种**方式，使用 Java 代码的方式，配置 Servlet、Filter、Listener 。分别是：

- 通过 Bean 的方式

  > 在 Spring Boot 中：
  >
  > 提供了 ServletRegistrationBean 来配置 Servlet Bean；
  >
  > 提供了 FilterRegistrationBean 来配置 Filter Bean；
  >
  > 提供了 ServletListenerRegistrationBean 来配置 Listener Bean ；

- 通过注解的方式，常用

> 在 Servlet3.0 的新特性里，提供了 `@WebServlet`、`@WebFilter`、`@WebListener` 三个注解，方便配置 Servlet、Filter、Listener 。
>
> 而在 SpringBoot 中，我们仅需要在 Application 类上，添加 `@ServletComponentScan`注解，**开启**对 `@WebServlet`、`@WebFilter`、`@WebListener` 注解的扫描。不过要**注意**，当且仅当使用**内嵌**的 Web Server 才会生效。

```java
// TestServlet02.java
@WebServlet(urlPatterns = "/test/02")
public class TestServlet02 extends HttpServlet {
    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        logger.info("[doGet][uri: {}]", req.getRequestURI());
    }
}

// TestFilter02.java
@WebFilter("/test/*")
public class TestFilter02 implements Filter {
    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        logger.info("[doFilter]");
        filterChain.doFilter(servletRequest, servletResponse);
    }
}

// TestServletContextListener02.java
@WebListener
public class TestServletContextListener02 implements ServletContextListener {
    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        logger.info("[contextInitialized]");
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
    }
}
```

**Filter 与 Interceptor的区别：**

![2205610-ace29d83875b2b9f](images/2205610-ace29d83875b2b9f.png)

上图很形象的说明了 `Filter` 与 `Interceptor` 的区别，一个作用在 `DispatcherServlet` 调用前，一个作用在调用后。但实际上，它们本身并没有任何关系，是完全独立的概念。

Filter` 由 `Servlet` 标准定义，要求 `Filter` 需要在 `Servlet` 被调用之前调用，作用顾名思义，就是用来过滤请求。在 `Spring Web` 应用中，`DispatcherServlet` 就是唯一的 `Servlet` 实现。

Interceptor` 由 Spring 自己定义，由 `DispatcherServlet` 调用，可以定义在 `Handler` 调用前后的行为。这里的 `Handler` ，在多数情况下，就是我们的 `Controller` 中对应的方法。

#### Cors跨域

在前后端分离之后，我们会碰到跨域的问题。例如说，前端在 <http://www.iocoder.cn> 域名下，而后端 API 在 <http://api.iocoder.cn> 域名下。

解决跨域的方式有很多，例如说，在 Nginx 上配置处理跨域请求的参数。又例如说，项目中有网关服务，统一配置处理。使用 SpringMVC 来解决跨域，目前一共有三种方案：

- 方式一，使用 [`@CrossOrigin`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/CrossOrigin.java) 注解，配置每个 API 接口。
- 方式二，使用 [`CorsRegistry.java`](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/CorsRegistry.java) 注册表，配置每个 API 接口。
- 方案三，使用 [`CorsFilter.java`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/filter/CorsFilter.java) **过滤器**，处理跨域请求。

```java
//方式三
@Bean
public FilterRegistrationBean<CorsFilter> corsFilter() {
    // 创建 UrlBasedCorsConfigurationSource 配置源，类似 CorsRegistry 注册表
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    // 创建 CorsConfiguration 配置，相当于 CorsRegistration 注册信息
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(Collections.singletonList("*")); // 允许所有请求来源
    config.setAllowCredentials(true); // 允许发送 Cookie
    config.addAllowedMethod("*"); // 允许所有请求 Method
    config.setAllowedHeaders(Collections.singletonList("*")); // 允许所有请求 Header
    // config.setExposedHeaders(Collections.singletonList("*")); // 允许所有响应 Header
    config.setMaxAge(1800L); // 有效期 1800 秒，2 小时
    source.registerCorsConfiguration("/**", config);
    // 创建 FilterRegistrationBean 对象
    FilterRegistrationBean<CorsFilter> bean = new FilterRegistrationBean<>(
            new CorsFilter(source)); // 创建 CorsFilter 过滤器
    bean.setOrder(0); // 设置 order 排序。这个顺序很重要哦，为避免麻烦请设置在最前
    return bean;
}
```

#### HttpMessageConverter 消息转换器

在 Spring MVC 中，可以使用 `@RequestBody` 和 `@ResponseBody` 两个注解，分别完成**请求报文到对象**和**对象到响应报文**的转换，底层这种灵活的消息转换机制，就是 Spring 3.x 中新引入的 [HttpMessageConverter](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/converter/HttpMessageConverter.java) ，即消息转换器机制。

在上面的示例里，我们已经看到，我们明明返回的是 UserVO 对象，最后输出给前端时，变成了 JSON 字符串，这就是使用了 [MappingJackson2HttpMessageConverter](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/converter/json/MappingJackson2HttpMessageConverter.java) 消息转换器，将 UserVO 对象转换成 JSON 字符串，写回给前端。

在一些业务场景下，前端提交给后端 API 参数，比较复杂，那么可能我们希望能够使用 JSON 的格式，提交给后端 API 
接口。此时，我们又可以使用 MappingJackson2HttpMessageConverter 消息转换器，将 JSON 字符串，转换成对应的对象。

```java
// HttpMessageConverter.java

// 是否能够读取指定的 mediaType 内容类型，转换成对应的 clazz 对象
boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);
// 读取请求内容，转换成 clazz 对象
T read(Class<? extends T> clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException;

// 是否能够将 clazz 对象，序列化成 mediaType 内容类型
boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);
// 将 clazz 对象，序列化成 contentType 内容类型，写入到响应。
void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException;

// 获得 HttpMessageConverter 能够支持的内容类型。
List<MediaType> getSupportedMediaTypes();

```

- 在**请求**时，我们在请求头 `Content-Type` 上，表示请求内容（Request Body）的类型。这样，SpringMVC 会从自己的 HttpMessageConverter **数组**中，通过 `#canRead(clazz, mediaType)` 方法，判断是否够读取指定的 `mediaType` 内容类型，转换成对应的 `clazz` 对象。如果可以，则调用 `#read(Class<? extends T> clazz, HttpInputMessage inputMessage)` 方法，读取请求内容，转换成 `clazz` 对象。
- 在**响应**时，我们在请求头 `Accept` 上，表示响应内容（Response Body）的类型。这样，SpringMVC 会从自己的 HttpMessageConverter **数组**中，通过 `#canWrite(clazz, mediaType)` 方法，判断是否能够将 `clazz` 对象，序列化成 `mediaType` 内容类型。如果可以，则调用 `#write(contentType, outputMessage)` 方法， 将 `clazz` 对象，序列化成 `contentType` 内容类型，写入到响应。

```java
// SpringMVCConfiguration.java
//修改 SpringMVCConfiguration 配置类，增加 MappingJackson2XmlHttpMessageConverter 相关的配置，用于 XML 格式的 HttpMessageConverter 消息转换器。
@Override
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
    // 增加 XML 消息转换器
    Jackson2ObjectMapperBuilder xmlBuilder = Jackson2ObjectMapperBuilder.xml();
    xmlBuilder.indentOutput(true);
    converters.add(new MappingJackson2XmlHttpMessageConverter(xmlBuilder.build()));
}
```

### 分布式Session

> Cookie：是一个非常具体的东西，指的是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。
>
> Session：会话。服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”（sessionId），然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。
>
> Token：基于Token的身份验证。
>
> 1. 用户登录校验，校验成功后就返回Token给客户端。
> 2. 客户端收到数据后保存在客户端
> 3. 客户端每次访问API是携带Token到服务器端。
> 4. 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码

#### 前因后果

我们部署生产环境下的 Tomcat 等 Web 容器的时候，**一定是需要部署多个节点**。此时，Session 的**一致性**就成为一个问题。

我们先以用户使用浏览器，Web 服务器为**单台** TomcatA 举例子：

- 浏览器在第一次访问 Web 服务器 TomcatA 时，TomcatA 会发现请求的 Cookie 中**不**存在 sessionid ，所以创建一个 sessionid 为 X 的 Session ，同时将该 sessionid 写回给浏览器的 Cookie 中。
- 浏览器在下一次访问 Web 服务器 TomcatA 时，TomcatA 会发现请求的 Cookie 中**已**存在 sessionid 为 X ，则直接获得 X 对应的 Session 。

我们再以用户使用浏览器，Web 服务器为**两台** TomcatA、TomcatB 举例子：

- 接上述例子，浏览器已经访问 TomcatA ，获得 sessionid 为 X 。同时，在多台 Tomcat 的情况下，我们需要采用 Nginx 做负载均衡。
- 浏览器又发起一次请求访问 Web 服务器，Nginx 负载均衡转发请求到 TomcatB 上。TomcatB 会发现请求的 Cookie 中**已**存在 sessionid 为 X ，则直接获得 X 对应的 Session 。结果呢，找不到 X 对应的 Session ，只好创建一个 sessionid 为 X 的 Session 。
- 此时，虽然说浏览器的 sessionid 是 X ，但是对应到两个 Tomcat 中两个 Session 。那么，如果在 TomcatA 上做的 Session 修改，TomcatB 的 Session 还是原样，这样就会出现 **Session 不一致**的问题。

既然会出现 Session 不一致的问题，我们就要想办法让它们一致。一般来说，有三种方案：

**第一种，Session 黏连**。

使用 Nginx 实现会话黏连，将相同 sessionid 的浏览器所发起的请求，转发到同一台服务器。这样，就不会存在多个 Web 服务器创建多个 Session 的情况，也就不会发生 Session 不一致的问题。

不过，这种方式目前基本不被采用。因为，如果一台服务器重启，那么会导致转发到这个服务器上的 Session 全部丢失。

**第二种，Session 复制**。

Web 服务器之间，进行 Session 复制同步。仅仅适用于实现 Session 复制的 Web 容器，例如说 Tomcat 、Weblogic 等等。

不过，这种方式目前基本也不被采用。试想一下，如果我们有 5 台 Web 服务器，所有的 Session 都要同步到每一个节点上，一个是效率低，一个是浪费内存。

**第三种，Session 外部化存储**。

不同于上述的两种方案，Session 外部化存储，考虑不再采用 Web 容器的内存中存储 Session ，而是将 Session 
存储外部化，持久化到 MySQL、Redis、MongoDB 等等数据库中。而实现 Session 外部化存储也有两种方式：

- 基于 Tomcat、Jetty 等 Web 容器**自带的拓展**，使用读取外部存储器的 Session 管理器；
- 基于应用层封装 [HttpServletRequest](https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/http/HttpServletRequest.java) 请求对象，包装成自己的 RequestWrapper 对象，从而让实现调用 [`HttpServletRequest#getSession()`](https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/http/HttpServletRequest.java#L542-L581) 方法时，获得读写外部存储器的 SessionWrapper 对象；



## hello word

**pom文件：**

```xml
//父级项目
<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.7.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
 </parent>

//依赖starter
<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
</dependencies>

//插件
 <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
  </build>

```

**程序入口：**

```java
@SpringBootApplication
public class StudyApplication {
    public static void main(String[] args) {
        SpringApplication.run(StudyApplication.class, args);
    }
}
```

**controller：**

```java
@RestController
@RequestMapping("/test")
public class HelloController {
    @RequestMapping("/hello")
    public String hello(){
        return "hello word...";
    }
}
```

**执行：**

```java
直接执行main方法；
通过maven package 打成jar包，通过java -jar jar包；
```

## 探究

- 父级项目


spring‐boot‐starter‐parent的父级项目是spring‐boot‐dependencies，Spring Boot的版本仲裁中心，管理Spring Boot应用里面的所有依赖版本。

> 以后我们导入依赖默认是不需要写版本的；
>
> 没有在spring‐boot‐dependencies里面管理的依赖是需要声明版本号的；

- stater

场景启动器，Spring Boot将所有的功能场景都抽取出来，做成一个个的starter（启动器）。只需要在项目里面引入这些starter，相关场景的所有依赖都会导入进来。

如：spring‐boot‐starter‐web，帮我们导入了web模块正常运行所依赖的组件。

- 入口类

@SpringBootApplication：标注在某个类上，说明这个类是SpringBoot的主配置类，可通过main方法来启动SpringBoot应用。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { 
  @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
  @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
  .....
}
```

其中：

**@SpringBootConfifiguration**：标注在某个类上，表示该类是Spring Boot的配置类。

> 其实就是对@Confifiguration的进一步封装；
>
> 相当于配置文件中的<beans/>节点；
>
> 配置类会注册到spring容器中，@Component

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration {
  .....
}

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {
 .... 
}
```

**@ComponentScan**：自动扫描指定包下所有使用@Service,@Component,@Controller,@Repository等注解的类并注册到容器中。

> Value：指定要扫描的包；
>
> excludeFilters：指定扫描的时候按照什么规则排除哪些组件，值是@Filter[]；
>
> includeFilters：指定扫描的时候只需要包含哪些组件，值是@Filter[]；
>
> useDefaultFilters：是否使用默认的过滤规则，默认为true，扫描所有类。若使用了includeFilters属性，则此属性需设值为false。

**@EnableAutoConfiguration**：开启自动配置功能。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
 ..... 
}
```

@AutoConfigurationPackage：**添加该注解的类所在的package** 作为 **自动配置package** 进行管理。

```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {

}
```

重点是@Import(AutoConfigurationPackages.Registrar.class)，Spring的底层注解@Import：快速给容器中导入组件。

AutoConfifigurationPackages.Registrar.class，将主配置类（@SpringBootApplication标注的类）所在包及下面所有子包的所有组件扫描到Spring容器。

也就是说当SpringBoot应用启动时默认会将启动类所在的package作为自动配置的package。

**@Import(AutoConfigurationImportSelector.class)：导入组件的选择器**。

该选择器是将所有需要导入的组件以全类名的方式返回，这些组件会被添加到容器中。会给容器导入非常多的自动配置类(xxxAutoConfiguration)，就是给容器中导入这个场景所有的组件，并配置好这些组件。

```java
public class AutoConfigurationImportSelector
		implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware,
		BeanFactoryAware, EnvironmentAware, Ordered {
	.....
	@Override
	public String[] selectImports(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return NO_IMPORTS;
		}
		try {
			AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader
					.loadMetadata(this.beanClassLoader);
			AnnotationAttributes attributes = getAttributes(annotationMetadata);
			List<String> configurations = getCandidateConfigurations(annotationMetadata,
					attributes);
			configurations = removeDuplicates(configurations);
			configurations = sort(configurations, autoConfigurationMetadata);
			Set<String> exclusions = getExclusions(annotationMetadata, attributes);
			checkExcludedClasses(configurations, exclusions);
			configurations.removeAll(exclusions);
			configurations = filter(configurations, autoConfigurationMetadata);
			fireAutoConfigurationImportEvents(configurations, exclusions);
			return StringUtils.toStringArray(configurations);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
}
```

重点是：

```java
List<String> configurations = getCandidateConfigurations(annotationMetadata,attributes);
```

获取到配置类的全类名数组，如下图：

![微信截图_20200508203455](images\微信截图_20200508203455.png)

底层是通过：

```java
SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；
```

从类路径下的META-INF/spring.factories中获取EnableAutoConfifiguration指定的值，并将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。

J2EE的整合解决方案和自动配置都在spring-boot-autoconfifigure-2.6.6 RELEASE.jar的META-INF/spring.factories中：

![微信图片_20200508204409](images\微信图片_20200508204409.png)

## 配置文件

resources文件夹中目录结构：

- static：保存所有的静态资源，如 js css images；


- templates：保存所有的模板页面，Spring Boot默认使用嵌入式的Tomcat，故不支持JSP页面，可以使用模板引擎（freemarker、thymeleaf）；


- application.properties：Spring Boot应用的配置文件，可以修改一些默认设置；

SpringBoot使用一个全局的配置文件，配置文件名是固定的：

- application.properties


- application.yml

配置文件的作用：修改SpringBoot自动配置的默认值。

### YAML语法

- 大小写敏感
- 使用缩进表示层级关系
- 缩进不允许使用tab，只允许空格
- 缩进的空格数不重要，只要相同层级的元素左对齐即可
- '#'表示注释

### 数据类型

纯量和数组的key代表的是类中的成员变量，对象的key代表的是类中的成员变量，key1...代表的是成员对象中的成员变量。

- 纯量

包括字符串、布尔值、整数、浮点数、Null、时间、日期。

使用冒号结构表示 **key: value**，冒号后面要加一个空格。

> ""：双引号不会转义字符串里面的特殊字符，如name: "zhangsan \n lisi"：输出；zhangsan 换行 lisi；
>
> ''：单引号会转义特殊字符如name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi；

- 数组（List或Set）

以 - 开头的行表示构成一个数组。

```
key:
‐ value1
‐ value2
‐ value3
行内写法：
key: [value1,value2,value3]
```

- 对象（Map或Object）

对象键值对使用冒号结构表示 **key: value**，冒号后面要加一个空格。

也可以使用 **key:{key1: value1, key2: value2, ...}**。

还可以使用缩进表示层级关系。

```
常用写法：
key: 
    child-key: value
    child-key2: value2
行内写法：
key:{child-key: value, child-key2: value2}
```

### 配置文件读取

- @Value


```yaml
#application.yml配置
#value 获取配置信息
valueParam1:
 name: valuevalue1
valueParam2: valuevalue2
```

```java
@Data
@Component//注意此处，需要注入到容器中
public class ValuePojo {
    @Value("${valueParam1.name}")
    private String valueParam1;

    @Value("${valueParam2}")
    private String valueParam2;
}
```

- @PropertySource+@Valuel

若不使用默认的配置文件，即application.properties、application.yml，则可以使用@PropertySource指定配置文件。

@PropertySource不支持读取 .yml 文件。

```yaml
#test.properties配置
#value 获取配置信息
valueParam1.name=valuevalue1
valueParam2=valuevalue2
```

```java
@Data
@Component
@PropertySource(value = {"classpath:test.properties"})//注意路径写法
public class ValuePojo {
    @Value("${valueParam1.name}")
    private String valueParam1;

    @Value("${valueParam2}")
    private String valueParam2;
}
```

- @ConfigurationProperties

```yaml
#application.yml文件
person:
  lastName: hello
  age: 18
  boss: false
  birth: 2017/12/12
  maps: {k1: v1,k2: v2}
  lists:
    - lisi
    - zhaoliu
  dog:
    name: 小狗
    age: 12
```

```java
@Data
@ConfigurationProperties(prefix = "person")//映射配置文件中前缀为person的配置信息，默认映射全局文件
@Component//需要注入到容器中
public class Person {
    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;
    private Map<String, Object> maps;
    private List<Object> lists;
    private Dog dog;
}

@Data
class Dog {
    private String name;
    private String age;
}
```

- @PropertySource+@ConfigurationProperties

道理和@PropertySource+@Value一样，可以参考下。

> 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 
>
> 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfifigurationProperties； 

**注意**：

- 如果@ConfigurationProperties所注的类可以被springboot扫描并添加进容器中作为bean（比如使用@Component等注解，或者配置扫描该类所在包等手段），那么spring容器会自动使该类上的@ConfigurationProperties生效，创建一个该类的实例，然后把对应配置属性绑定进该实例，再把该实例作为bean添加进spring容器。
- 如果该类只使用了@ConfigurationProperties注解，然后该类没有在扫描路径下或者没有使用@Component等注解，导致无法被扫描为bean，那么就必须在配置类上使用@EnableConfigurationProperties注解去指定这个类，这个时候就会让该类上的@ConfigurationProperties生效，然后作为bean添加进spring容器中

- 在javaconfig中@ConfigurationProperties与@Bean一起用，也是把配置文件中的属性注入该@Bean对应的要添加到容器中的bean实例中。

### 配置文件加载位置

分别从以下四个位置依次读取后缀名为properties, xml, yml, yaml的配置文件：

```yaml
-file:./config/
 -file:./
  -classpath:/config
   -classpath:/
```

- 优先级由高到低，对于相同的属性配置，高优先级的配置会覆盖优先级低的配置；
- 对于其他不同的属性配置，则会进行互补；
- 优先级相同的情况下，同时有application.properties和application.yml，那么application.properties里面的属性就会覆盖application.yml里的属性，因为properties比yml优先加载；

![9id84g5xi9](images/9id84g5xi9.png)

> 还可以通过spring.confifig.location来改变默认的配置文件位置 

### 外部配置加载顺序

spring boot不仅可以从工程的resource文件夹或者config文件夹下加载配置，还可以在以下位置加载配置：

    命令行参数
    来自java:comp/env的JNDI属性
    Java系统属性(System.getProperties())
    操作系统环境变量
    RandomValuePropertyResource配置的random.*属性值
    jar包外部的application-{profile}.properties或application.yaml（带spring.profile）配置文件
    jar包内部的application-{profile}.properties或application.yaml（带spring.profile）配置文件
    jar包外部的application.properties或application.yaml（不带spring.profile）配置文件
    jar包内部的application.properties或application.yaml（不带spring.profile）配置文件
    @Configuration注解类上的@PropertySource
    通过SpringApplication.setDefaultProperties指定的默认属性

其中上述中的6-9是我们需要重点掌握内容，从上向下优先级越来越低，高优先级的配置会覆盖低优先级的配置，高优先级的配置和低优先级的配置都会生效，形成互补配置。

## 多环境配置 profile

一个应用为了在不同的环境下工作，常常会有不同的配置，代码逻辑处理。Spring Boot 对此提供了简便的支持。假设，一个应用的工作环境有：dev、test、prod。

### properties 配置

- `applcation.properties` - 公共配置
- `application-dev.properties` - 开发环境配置
- `application-test.properties` - 测试环境配置
- `application-prod.properties` - 生产环境配置

在 `applcation.properties` 文件中可以通过以下配置来激活 profile：

```yaml
spring.profiles.active = test
```

### yml 配置

与 properties 文件类似，我们也可以添加 4 个配置文件：

- `applcation.yml` - 公共配置
- `application-dev.yml` - 开发环境配置
- `application-test.yml` - 测试环境配置
- `application-prod.yml` - 生产环境配置

在 `applcation.yml` 文件中可以通过以下配置来激活 profile：

```yaml
spring:
  profiles:
    active: prod #此处的值与application-{xxx}的xxx一样
```

此外，yml 文件也可以在一个文件中完成所有 profile 的配置：

```yaml
# 激活 prod
spring:
  profiles:
    active: prod
# 也可以同时激活多个 profile
# spring.profiles.active: prod,proddb,prodlog
---
# dev 配置
spring:
  profiles: dev
# 略去配置
---
# test 配置
spring:
  profiles: test
# 略去配置
---
# prod 配置
spring：
  profiles: prod
# 略去配置
```

注意：不同 profile 之间通过 `---` 分割。

使用 `@Profile` 注解可以指定类或方法在特定的 Profile 环境生效，如：@Profile("production")。

### 激活

在配置文件中指定 spring.profifiles.active=dev；

命令行： java -jar xxxxx.jar --spring.profifiles.active=dev； 

## 自动配置原理

```java
SpringBoot启动的时候加载主配置类，@EnableAutoConfifiguration 开启了自动配置功能；
利用AutoConfigurationImportSelector（自动配置导入选择器），扫描所有jar包下 META‐INF/spring.factories文件；
把文件的内容包装成Properties对象 ，从Properties中获取到EnableAutoConfiguration.class类对应的值（xxxAutoConfiguration类），然后把他们添加在到容器中。 
通过这些xxxAutoConfiguration类，根据@Conditional条件来进行自动配置功能；
```

以HttpEncodingAutoConfifiguration（Http编码自动配置）为例：

```java
//表示这是一个配置类，并添加到容器中
@Configuration(proxyBeanMethods = false)
//启动HttpProperties类的 ConfigurationProperties功能，并将HttpProperties类添加到容器
//HttpProperties属性类，与配置文件映射
@EnableConfigurationProperties(HttpProperties.class)
//条件注解
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass(CharacterEncodingFilter.class)
@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)
public class HttpEncodingAutoConfiguration {

	private final HttpProperties.Encoding properties;//属性类，与配置文件映射

	public HttpEncodingAutoConfiguration(HttpProperties properties) {
		this.properties = properties.getEncoding();
	}

	@Bean
	@ConditionalOnMissingBean//条件成立，则注入组件CharacterEncodingFilter
	public CharacterEncodingFilter characterEncodingFilter() {
		CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
		filter.setEncoding(this.properties.getCharset().name());
		filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
		filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
		return filter;
	}
}
```

```
@ConfigurationProperties(prefix = "spring.http")//配置文件中前缀为spring.http的配置
public class HttpProperties {
	....//省略属性
}
```

> 根据当前不同的条件判断，决定这个配置类是否生效。
>
> 若这个配置类生效，就会给容器中添加各种组件。这些组件的属性是从对应的XXXProperties类中获取的，这些XXXProperties类里面的每一个属性又是和配置文件绑定的。
>
> 所以，配置文件能配置什么就可以参照某个功能对应的XXXProperties类 。

@Conditional派生注解，必须是指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效，如下：

| @Conditional扩展注解                | 作用（判断是否满足当前指定条件）               |
| :------------------------------ | :----------------------------- |
| @ConditionalOnJava              | 系统的java版本是否符合要求                |
| @ConditionalOnBean              | 容器中存在指定Bean                    |
| @ConditionalOnMissingBean       | 容器中不存在指定Bean                   |
| @ConditionalOnExpression        | 满足SpEL表达式指定                    |
| @ConditionalOnClass             | 系统中有指定的类                       |
| @ConditionalOnMissingClass      | 系统中没有指定的类                      |
| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选Bean |
| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                |
| @ConditionalOnResource          | 类路径下是否存在指定资源文件                 |
| @ConditionalOnWebApplication    | 当前是web环境                       |
| @ConditionalOnNotWebApplication | 当前不是web环境                      |
| @ConditionalOnJndi              | JNDI存在指定项                      |

小知识：

```yaml
debug: true #让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效
```

# 日志框架

市面上的日志框架：

| 日志门面 （日志的抽象层）                            | 日志实现                                     |
| :--------------------------------------- | ---------------------------------------- |
| ~~JCL（Jakarta Commons Logging）~~ 、SLF4j（Simple Logging Facade for Java）、 ~~jboss-logging~~ | Log4j、 JUL（java.util.logging）、 **Log4j2**、 **Logback** |

## SLF4j实现

![concrete-bindings](C:\Users\Administrator\Desktop\道心不破\images\concrete-bindings.png)

**每一个日志的实现框架都有自己的配置文件，使用slf4j后，配置文件还是做成日志实现框架本身的配置文件。**

## 遗留问题

让系统中所有的日志都统一到slf4j：

- 先排除其他日志框架；
- 用中间包来替换原有的日志框架； 
- 导入slf4j其他的实现 ；

![legacy](C:\Users\Administrator\Desktop\道心不破\images\legacy.png)

## SpringBoot日志

```
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
      <version>2.2.7.RELEASE</version>
      <scope>compile</scope>
    </dependency>
    //中的
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-logging</artifactId>
      <version>2.2.7.RELEASE</version>
      <scope>compile</scope>
    </dependency>
```

使用spring-boot-starter-logging来实现日志框架，底层关系如下：

![搜狗截图20180131220946](C:\Users\Administrator\Desktop\道心不破\images\搜狗截图20180131220946.png)

> SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ；
>
> SpringBoot通过中间替换包把其他的日志实现都替换成了slf4j； 

**如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉**！例如Spring框架用的是commons-logging，SpringBoot是这样做的：

```xml
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring‐core</artifactId>
  <exclusions>
    <exclusion>
      <groupId>commons‐logging</groupId>
      <artifactId>commons‐logging</artifactId>
    </exclusion>
  </exclusions>
</dependency>
```

**SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可。**

## lombak日志使用

可以在全局配置文件中配置，但Spring Boot官方推荐优先使用带有-spring的文件名作为日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，将xml放至 src/main/resource下面。

> 也可以使用自定义的名称，比如logback-config.xml，只需要在application.properties文件中使用logging.config=classpath:logback-config.xml指定即可。

logback-spring.xml配置可以使用spring boot的高级级Profifile功能，即指定在哪个环境使用。

例子：

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@SpringBootTest
public class LogTest {
    Logger logger = LoggerFactory.getLogger(getClass());
    @Test
    public void log(){
        //日志就只会在这个级别以后的高级别生效
        //trace<debug<info<warn<error      
        logger.trace("trace...");
        logger.debug("debug...");
        logger.info("info...");//默认
        logger.warn("warn...");
        logger.error("error...");
        logger.debug("The new entry is {}. It replaces {}.", entry, oldEntry);//推荐使用此格式
    }
}
```

xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--
scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。
scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。
debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。
-->
<configuration scan="false" scanPeriod="60 seconds" debug="false">
    <!-- 定义日志的根目录 -->
    <property name="LOG_HOME" value="/app/log" />
    <!-- 定义日志文件名称 -->
    <property name="appName" value="atguigu-springboot"></property>
  
    <!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 -->
    <appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
        <!--
        日志输出格式：
			%d表示日期时间，
			%thread表示线程名，
			%-5level：级别从左显示5个字符宽度
			%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 
			%msg：日志消息，
			%n是换行符
        -->
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
        </layout>
    </appender>

    <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 -->  
    <appender name="appLogAppender" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- 指定日志文件的名称 -->
        <file>${LOG_HOME}/${appName}.log</file>
        <!--
        当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名
        TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。
        -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--
            滚动时产生的文件的存放位置及文件名称 %d{yyyy-MM-dd}：按天进行日志滚动 
            %i：当文件大小超过maxFileSize时，按照i进行文件滚动
            -->
            <fileNamePattern>${LOG_HOME}/${appName}-%d{yyyy-MM-dd}-%i.log</fileNamePattern>
            <!-- 
            可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动，
            且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是，
            那些为了归档而创建的目录也会被删除。
            -->
            <MaxHistory>365</MaxHistory>
            <!-- 
            当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy
            -->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <!-- 日志输出格式： -->     
        <layout class="ch.qos.logback.classic.PatternLayout">
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [ %thread ] - [ %-5level ] [ %logger{50} : %line ] - %msg%n</pattern>
        </layout>
    </appender>

    <!-- 
		logger主要用于存放日志对象，也可以定义日志类型、级别
		name：表示匹配的logger类型前缀，也就是包的前半部分
		level：要记录的日志级别，包括 TRACE < DEBUG < INFO < WARN < ERROR
		additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，
		false：表示只用当前logger的appender-ref，true：
		表示当前logger的appender-ref和rootLogger的appender-ref都有效
    -->
    <!-- hibernate logger -->
    <!-- z指定包级别的日志输出 -->
    <logger name="com.atguigu" level="debug" />
    <!-- Spring framework logger -->
    <logger name="org.springframework" level="debug" additivity="false"></logger>

    <!-- 
    root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应，
    要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 
    -->
  <!-- 当spring.profiles.active为dev时激活 -->
    <!-- 参考‘Spring Boot：boot-features-logging’中的‘Profile-specific configuration’ -->
    <springProfile name="dev">
        <root level="INFO">
           <appender-ref ref="stdout" />
           <appender-ref ref="appLogAppender" />
        </root>
    </springProfile>

    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="" />
        </root>
    </springProfile>
</configuration> 
```

利用kafak异步输出日志：https://www.zhangjianbing.com/archives/38/

# spring-boot-devtools

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional> <!-- 可选 -->
</dependency>=
```

`spring-boot-devtools` 是 `Spring Boot` 提供的开发者工具，它会监控当前应用所在的 `classpath` 下的文件发生变化，进行**自动重启**。

注意，`spring-boot-devtools` 并**没有**采用热部署的方式，而是一种较快的重启方式。其官方文档解释如下：

Spring Boot 通过使用两个类加载器来提供了重启技术。

- 不改变的类（例如，第三方 jar）被加载到 **base** 类加载器中。
- 经常处于开发状态的类被加载到 **restart** 类加载器中。

当应用重启时，**restart** 类加载器将被丢弃，并重新创建一个新的。这种方式意味着应用重启比**冷启动**要快得多，因为省去 **base** 类加载器的处理步骤，并且可以直接使用。

**【关键】** 我们现在仅仅需要修改了 Java 代码，需要重新编译下代码。点击 IDEA 的菜单 `Build` -> `Build Project`，**手动**进行编译。

# MapStruct对象转换

对于代码中 `JavaBean`之间的转换：

- 第一种通过反射的方法确实比较方便， 但是现在无论是 `BeanUtils`, `BeanCopier` 等在使用反射的时候都会影响到性能。
- 第二种的话就是会很浪费时间， 而且在添加新的字段的时候也要进行方法的修改。 不过， 由于不需要进行反射， 其性能是很高的。

`MapSturct` 是一个生成类型安全， 高性能且无依赖的 JavaBean 映射代码的注解处理器。

```xml
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-jdk8</artifactId>
    <version>1.3.1.Final</version>
</dependency>
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-processor</artifactId>
    <version>1.3.1.Final</version>
</dependency>
```

## 属性名称相同

只有一个要求， 在接口上写 `@Mapper` 注解即可。 然后方法上， 入参对应要被转化的对象， 返回值对应转化后的对象， 方法名称可任意。

```java
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
@Mapper
public interface TargetMapper {
    Target source2Target(Source source);
}
```

在 target/generated-sources/annotations 里可以看到通过 `MapStruct` 来生成的代码， 其类似于人手写，我们可以轻易的进行 debug。

## 属性名称不相同

属性名不相同， 在需要进行互相转化的时候， 则我们可以通过 `@Mapping` 注解来进行转化。

```java
    @Mapper
    public interface TargetMapper {
        TargetMapper INSTANCE = Mappers.getMapper(TargetMapper.class);
       @Mappings(value={
　　		@Mapping(target="abc", source="cba"),
　　		@Mapping(target="acc", source="cca", qualifiedByName="mapMethodName2"), //定义转换的方法
　　		@Mapping(target="aaa",  constant="123")  //定义常量
		})
        Target source2target(Source source);
    }
```

## 使用自定义的转换

```java
    @Mapper
    public interface TargetMapper {
        TargetMapper INSTANCE = Mappers.getMapper(TargetMapper.class);
        default Target source2target(Source source) {
            if (source == null) {
                return null;
            }
            Target target = new Target();
            ....
            return target;
        }
    }
```



## 多转一

```
    @Mapper
    public interface TargetMapper {
        TargetMapper INSTANCE = Mappers.getMapper(TargetMapper.class);
        @Mapping(source = "source1.para", target = "para")
        @Mapping(source = "source2.para", target = "para")
        Target sources2target(Source1 source1, Source2 source2);
    }
```

在多对一转换时， **遵循以下几个原则**

- 当多个对象中， 有其中一个为 null， 则会直接返回 null
- 如一对一转换一样， 属性通过名字来自动匹配。 因此， 名称和类型相同的不需要进行特殊处理
- 当多个原对象中，有相同名字的属性时，需要通过 `@Mapping` 注解来具体的指定， 以免出现歧义（不指定会报错）。 如上面的 `description`

## 更新 Bean 对象

有时候， 我们不是想返回一个新的 Bean 对象， 而是希望更新传入对象的一些属性。

```java
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
@Mapper
public interface TargetMapper {
    void updateSource(Source1 source1, @MappingTarget Source2 source2);
}
```

注解 `@MappingTarget`后面跟的对象会被更新。

## 总结

- 支持maven/gradle/ant工具所构建的项目；
- 在某些情况下，可能需要手动实现从一种类型到另一种类型的特定映射，而MapStruct无法生成这种映射，你可以向映射器中添加自定义方法；
- 可以用多个源对象的数据映射到一个对象上，也就是说可以同时把A和B的数据复制到C对象中；
- 可以通过引用更新目标对象，默认在复制时会生成新的对象并返回，但有时候可能不需要生成新的对象，只希望它在既有对象上进行复制；
- Bean的字段如果没有提供getter/setter方法也可以进行复制，它会通过实例直接访问属性来达到目的；
- 如果Bean提供了自己的工厂，即通过Builder构造自己，也可以被识别到；
- 获取映射器之后客户端才能调用，获取的方式支持Mappers工厂、CDI依赖注入和Spring依赖注入；
- 类型隐式转换；
- 嵌套对象自动映射；
- 在当前映射器中可以调用其他映射器，可以是自定义映射器；
- 集合映射；
- 流映射；
- 枚举类映射；
- 映射字段控制：常量，默认值，忽略字段，NULL值检查和处理策略，异常处理；
- 映射配置共享、继承和反向映射；
- 装饰器映射，也就是在映射前后做一些自定义操作；
- 提供SPI接口，可以修改框架的部分实现；

MapStruct 提供了 IDEA MapStruct Support 插件，让我们在 IDEA 中，可以更愉快的使用 MapStruct，牛逼啊！

